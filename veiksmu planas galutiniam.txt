Galutinis Veiksmų Planas: "Stateful" Prekybos Botas
Šis planas apibrėžia, kaip sukurti botą, kuris atsimena savo veiksmus (yra "stateful") ir valdo visą prekybos ciklą – nuo sąlyginio orderio pateikimo iki jo atšaukimo arba pozicijos valdymo.

1 Fazas: Pamatų Paklojimas ir Konfigūracija
Šiame etape paruošiame visus būtinus komponentus ir nustatymus.

Architektūros Apibrėžimas:

TradingView: Veikia kaip signalų generatorius.

Node.js Botas: Sistemos "smegenys". Priima signalus, valdo būseną, atlieka skaičiavimus, bendrauja su Bybit.

Bybit: Vykdymo platforma.

Būsenos Saugykla (State Store): Svarbiausias naujas elementas. Tai bus paprastas Map objektas jūsų Node.js kode, kuris veiks kaip boto "atmintis". Jame saugosime informaciją apie pateiktus, bet dar neaktyvuotus sąlyginius orderius.

JavaScript

// Boto kodo pradžioje
const pendingConditionalOrders = new Map();
Struktūra: Raktas (Key) bus unikalus prekybos poros ir krypties identifikatorius, pvz., "SOLUSDT_1" (long) arba "ETHUSDT_2" (short).

Reikšmė (Value): Bus objektas, kuriame saugosime iš Bybit gautą orderId, pvz., { orderId: "a1b2c3d4-e5f6-..." }.

TradingView Alertų Konfigūracija (Kritiškai Svarbu!):
Jūsų indikatoriaus nustatymuose (paveikslėlis, kurį rodėte) kiekvienam trigeriui reikia nustatyti Custom Message, kuris bus JSON formatu. Tai leis botui lengvai suprasti, kokį veiksmą atlikti.

Trigeris: New Pattern Found (Long pozicijai)

JSON

{
  "action": "NEW_PATTERN",
  "ticker": "{{ticker}}",
  "direction": "long",
  "positionIdx": 1,
  "entryPrice": "{{entry}}",
  "takeProfit": "{{target1}}"
}
Trigeris: New Pattern Found (Short pozicijai)

JSON

{
  "action": "NEW_PATTERN",
  "ticker": "{{ticker}}",
  "direction": "short",
  "positionIdx": 2,
  "entryPrice": "{{entry}}",
  "takeProfit": "{{target1}}"
}
Trigeris: Invalidated Pattern (Long pozicijai)

JSON

{
  "action": "INVALIDATE_PATTERN",
  "ticker": "{{ticker}}",
  "positionIdx": 1
}
Trigeris: Entered Position (Long pozicijai)

JSON

{
  "action": "ENTERED_POSITION",
  "ticker": "{{ticker}}",
  "positionIdx": 1,
  "stopLoss": "{{stoploss}}",
  "takeProfit": "{{target1}}"
}
Trigeris: Invalidated by the Age (Long pozicijai)

JSON

{
  "action": "CLOSE_BY_AGE",
  "ticker": "{{ticker}}",
  "positionIdx": 1
}
(Pastaba: Sukurkite analogiškus alertus ir Short pozicijoms, pakeisdami direction į "short" ir positionIdx į 2.)

2 Fazas: Boto Logikos Įgyvendinimas
Tai yra pagrindinė plano dalis, aprašanti, kaip botas turi reaguoti į kiekvieną action.

Veiksmas: NEW_PATTERN

Tikslas: Apskaičiuoti pozicijos dydį su 1:2 RR ir pateikti sąlyginį (conditional) orderį.

Eiga:

Botas gauna alertą su action: "NEW_PATTERN".

Skaičiuoja:

profitDistance = Math.abs(data.takeProfit - data.entryPrice)

riskDistance = profitDistance / 2

calculatedSlPrice = data.direction === 'long' ? data.entryPrice - riskDistance : data.entryPrice + riskDistance

Pagal calculatedSlPrice ir fiksuotą riziką (pvz., 1 USD) apskaičiuoja pozicijos dydi (qty).

Vykdo: Kreipiasi į Bybit API (bybitClient.submitOrder) ir pateikia sąlyginį rinkos orderį (stopOrderType: 'Market').

triggerPrice bus lygus data.entryPrice.

Būtinai nurodo positionIdx.

Įsimena: Jei orderis pateiktas sėkmingai, Bybit grąžins orderId. Botas jį įrašo į savo "atmintį":
pendingConditionalOrders.set(data.ticker + '_' + data.positionIdx, { orderId: bybitResponse.result.orderId });

Veiksmas: INVALIDATE_PATTERN

Tikslas: Atšaukti anksčiau pateiktą sąlyginį orderį.

Eiga:

Botas gauna alertą su action: "INVALIDATE_PATTERN".

Ieško "atmintyje": Pagal data.ticker ir data.positionIdx ieško įrašo pendingConditionalOrders.

Vykdo: Jei įrašas rastas, paima iš jo orderId ir kreipiasi į Bybit API (bybitClient.cancelOrder), kad atšauktų būtent tą orderį.

Pamiršta: Sėkmingai atšaukus, ištrina įrašą iš pendingConditionalOrders, kad neliktų pasenusių duomenų.

Veiksmas: ENTERED_POSITION

Tikslas: Nustatyti tikslius SL/TP lygius ką tik atidarytai pozicijai.

Eiga:

Botas gauna alertą su action: "ENTERED_POSITION".

Pamiršta: Sąlyginis orderis buvo įvykdytas, todėl jo nebereikia sekti. Botas ištrina įrašą iš pendingConditionalOrders.

Vykdo: Kreipiasi į Bybit API (bybitClient.setTradingStop) ir nurodo tikslius stopLoss ir takeProfit lygius, gautus su šiuo alertu. Ši komanda priskirs SL/TP jau atidarytai pozicijai.

Veiksmas: CLOSE_BY_AGE

Tikslas: Uždaryti poziciją, kuri per ilgai "užsistovėjo".

Eiga:

Botas gauna alertą su action: "CLOSE_BY_AGE".

Vykdo: Ši logika yra identiška tai, kurią jau turite. Botas tikrina, ar egzistuoja aktyvi pozicija (bybitClient.getPositionInfo). Jei taip, pateikia priešingos krypties rinkos orderį su reduceOnly: true, kad ją uždarytų.

3 Fazas: Testavimas ir Paleidimas
Vienetinis Testavimas (curl): Testuokite kiekvieną action atskirai, siųsdami rankines curl užklausas į savo botą. Taip galėsite patikrinti kiekvienos funkcijos logiką, nelaukdami realių signalų.

Pavyzdys NEW_PATTERN testavimui:

Bash

curl -X POST -H "Content-Type: application/json" -d '{
  "action": "NEW_PATTERN",
  "ticker": "SOLUSDT",
  "direction": "long",
  "positionIdx": 1,
  "entryPrice": "150.5",
  "takeProfit": "155.5"
}' http://JUSU_SERVERIO_IP:3000/webhook
Pilno Ciklo Testavimas: Bybit Testnet aplinkoje praeikite visą ciklą:

NEW_PATTERN -> INVALIDATE_PATTERN

NEW_PATTERN -> ENTERED_POSITION -> CLOSE_BY_AGE

Produkcinis Paleidimas: Kai įsitikinsite, kad viskas veikia teisingai, paleiskite botą serveryje su pm2, kaip aprašyta jūsų readme.html.

Šis planas suteikia jums tvirtą struktūrą ir aiškius žingsnius, kaip pasiekti norimą rezultatą.